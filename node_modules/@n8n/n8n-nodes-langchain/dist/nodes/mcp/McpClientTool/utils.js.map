{"version":3,"sources":["../../../../nodes/mcp/McpClientTool/utils.ts"],"sourcesContent":["import { DynamicStructuredTool, type DynamicStructuredToolInput } from '@langchain/core/tools';\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';\nimport { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport { CompatibilityCallToolResultSchema } from '@modelcontextprotocol/sdk/types.js';\nimport type { ClientOAuth2TokenData } from '@n8n/client-oauth2';\nimport { Toolkit } from 'langchain/agents';\nimport {\n\tcreateResultError,\n\tcreateResultOk,\n\ttype ILoadOptionsFunctions,\n\ttype ISupplyDataFunctions,\n\ttype IDataObject,\n\ttype IExecuteFunctions,\n\ttype Result,\n} from 'n8n-workflow';\nimport { z } from 'zod';\n\nimport { convertJsonSchemaToZod } from '@utils/schemaParsing';\n\nimport type {\n\tMcpAuthenticationOption,\n\tMcpServerTransport,\n\tMcpTool,\n\tMcpToolIncludeMode,\n} from './types';\n\nexport async function getAllTools(client: Client, cursor?: string): Promise<McpTool[]> {\n\tconst { tools, nextCursor } = await client.listTools({ cursor });\n\n\tif (nextCursor) {\n\t\treturn (tools as McpTool[]).concat(await getAllTools(client, nextCursor));\n\t}\n\n\treturn tools as McpTool[];\n}\n\nexport function getSelectedTools({\n\tmode,\n\tincludeTools,\n\texcludeTools,\n\ttools,\n}: {\n\tmode: McpToolIncludeMode;\n\tincludeTools?: string[];\n\texcludeTools?: string[];\n\ttools: McpTool[];\n}) {\n\tswitch (mode) {\n\t\tcase 'selected': {\n\t\t\tif (!includeTools?.length) return tools;\n\t\t\tconst include = new Set(includeTools);\n\t\t\treturn tools.filter((tool) => include.has(tool.name));\n\t\t}\n\t\tcase 'except': {\n\t\t\tconst except = new Set(excludeTools ?? []);\n\t\t\treturn tools.filter((tool) => !except.has(tool.name));\n\t\t}\n\t\tcase 'all':\n\t\tdefault:\n\t\t\treturn tools;\n\t}\n}\n\nexport const getErrorDescriptionFromToolCall = (result: unknown): string | undefined => {\n\tif (result && typeof result === 'object') {\n\t\tif ('content' in result && Array.isArray(result.content)) {\n\t\t\tconst errorMessage = (result.content as Array<{ type: 'text'; text: string }>).find(\n\t\t\t\t(content) => content && typeof content === 'object' && typeof content.text === 'string',\n\t\t\t)?.text;\n\t\t\treturn errorMessage;\n\t\t} else if ('toolResult' in result && typeof result.toolResult === 'string') {\n\t\t\treturn result.toolResult;\n\t\t}\n\t\tif ('message' in result && typeof result.message === 'string') {\n\t\t\treturn result.message;\n\t\t}\n\t}\n\n\treturn undefined;\n};\n\nexport const createCallTool =\n\t(name: string, client: Client, timeout: number, onError: (error: string) => void) =>\n\tasync (args: IDataObject) => {\n\t\tlet result: Awaited<ReturnType<Client['callTool']>>;\n\n\t\tfunction handleError(error: unknown) {\n\t\t\tconst errorDescription =\n\t\t\t\tgetErrorDescriptionFromToolCall(error) ?? `Failed to execute tool \"${name}\"`;\n\t\t\tonError(errorDescription);\n\t\t\treturn errorDescription;\n\t\t}\n\n\t\ttry {\n\t\t\tresult = await client.callTool({ name, arguments: args }, CompatibilityCallToolResultSchema, {\n\t\t\t\ttimeout,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\treturn handleError(error);\n\t\t}\n\n\t\tif (result.isError) {\n\t\t\treturn handleError(result);\n\t\t}\n\n\t\tif (result.toolResult !== undefined) {\n\t\t\treturn result.toolResult;\n\t\t}\n\n\t\tif (result.content !== undefined) {\n\t\t\treturn result.content;\n\t\t}\n\n\t\treturn result;\n\t};\n\nexport function mcpToolToDynamicTool(\n\ttool: McpTool,\n\tonCallTool: DynamicStructuredToolInput['func'],\n): DynamicStructuredTool {\n\tconst rawSchema = convertJsonSchemaToZod(tool.inputSchema);\n\n\t// Ensure we always have an object schema for structured tools\n\tconst objectSchema =\n\t\trawSchema instanceof z.ZodObject ? rawSchema : z.object({ value: rawSchema });\n\n\treturn new DynamicStructuredTool({\n\t\tname: tool.name,\n\t\tdescription: tool.description ?? '',\n\t\tschema: objectSchema,\n\t\tfunc: onCallTool,\n\t\tmetadata: { isFromToolkit: true },\n\t});\n}\n\nexport class McpToolkit extends Toolkit {\n\tconstructor(public tools: DynamicStructuredTool[]) {\n\t\tsuper();\n\t}\n}\n\nfunction safeCreateUrl(url: string, baseUrl?: string | URL): Result<URL, Error> {\n\ttry {\n\t\treturn createResultOk(new URL(url, baseUrl));\n\t} catch (error) {\n\t\treturn createResultError(error);\n\t}\n}\n\nfunction normalizeAndValidateUrl(input: string): Result<URL, Error> {\n\tconst withProtocol = !/^https?:\\/\\//i.test(input) ? `https://${input}` : input;\n\tconst parsedUrl = safeCreateUrl(withProtocol);\n\n\tif (!parsedUrl.ok) {\n\t\treturn createResultError(parsedUrl.error);\n\t}\n\n\treturn parsedUrl;\n}\n\nfunction isUnauthorizedError(error: unknown): boolean {\n\treturn (\n\t\t!!error &&\n\t\ttypeof error === 'object' &&\n\t\t(('code' in error && Number(error.code) === 401) ||\n\t\t\t('message' in error && typeof error.message === 'string' && error.message.includes('401')))\n\t);\n}\n\ntype OnUnauthorizedHandler = (\n\theaders?: Record<string, string>,\n) => Promise<Record<string, string> | null>;\n\ntype ConnectMcpClientError =\n\t| { type: 'invalid_url'; error: Error }\n\t| { type: 'connection'; error: Error };\n\nexport async function connectMcpClient({\n\theaders,\n\tserverTransport,\n\tendpointUrl,\n\tname,\n\tversion,\n\tonUnauthorized,\n}: {\n\tserverTransport: McpServerTransport;\n\tendpointUrl: string;\n\theaders?: Record<string, string>;\n\tname: string;\n\tversion: number;\n\tonUnauthorized?: OnUnauthorizedHandler;\n}): Promise<Result<Client, ConnectMcpClientError>> {\n\tconst endpoint = normalizeAndValidateUrl(endpointUrl);\n\n\tif (!endpoint.ok) {\n\t\treturn createResultError({ type: 'invalid_url', error: endpoint.error });\n\t}\n\n\tconst client = new Client({ name, version: version.toString() }, { capabilities: { tools: {} } });\n\n\tif (serverTransport === 'httpStreamable') {\n\t\ttry {\n\t\t\tconst transport = new StreamableHTTPClientTransport(endpoint.result, {\n\t\t\t\trequestInit: { headers },\n\t\t\t});\n\t\t\tawait client.connect(transport);\n\t\t\treturn createResultOk(client);\n\t\t} catch (error) {\n\t\t\tif (onUnauthorized && isUnauthorizedError(error)) {\n\t\t\t\tconst newHeaders = await onUnauthorized(headers);\n\t\t\t\tif (newHeaders) {\n\t\t\t\t\t// Don't pass `onUnauthorized` to avoid possible infinite recursion\n\t\t\t\t\treturn await connectMcpClient({\n\t\t\t\t\t\theaders: newHeaders,\n\t\t\t\t\t\tserverTransport,\n\t\t\t\t\t\tendpointUrl,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tversion,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn createResultError({ type: 'connection', error });\n\t\t}\n\t}\n\n\ttry {\n\t\tconst sseTransport = new SSEClientTransport(endpoint.result, {\n\t\t\teventSourceInit: {\n\t\t\t\tfetch: async (url, init) =>\n\t\t\t\t\tawait fetch(url, {\n\t\t\t\t\t\t...init,\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t...headers,\n\t\t\t\t\t\t\tAccept: 'text/event-stream',\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t},\n\t\t\trequestInit: { headers },\n\t\t});\n\t\tawait client.connect(sseTransport);\n\t\treturn createResultOk(client);\n\t} catch (error) {\n\t\tif (onUnauthorized && isUnauthorizedError(error)) {\n\t\t\tconst newHeaders = await onUnauthorized(headers);\n\t\t\tif (newHeaders) {\n\t\t\t\t// Don't pass `onUnauthorized` to avoid possible infinite recursion\n\t\t\t\treturn await connectMcpClient({\n\t\t\t\t\theaders: newHeaders,\n\t\t\t\t\tserverTransport,\n\t\t\t\t\tendpointUrl,\n\t\t\t\t\tname,\n\t\t\t\t\tversion,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn createResultError({ type: 'connection', error });\n\t}\n}\n\nexport async function getAuthHeaders(\n\tctx: Pick<IExecuteFunctions, 'getCredentials'>,\n\tauthentication: McpAuthenticationOption,\n): Promise<{ headers?: Record<string, string> }> {\n\tswitch (authentication) {\n\t\tcase 'headerAuth': {\n\t\t\tconst header = await ctx\n\t\t\t\t.getCredentials<{ name: string; value: string }>('httpHeaderAuth')\n\t\t\t\t.catch(() => null);\n\n\t\t\tif (!header) return {};\n\n\t\t\treturn { headers: { [header.name]: header.value } };\n\t\t}\n\t\tcase 'bearerAuth': {\n\t\t\tconst result = await ctx\n\t\t\t\t.getCredentials<{ token: string }>('httpBearerAuth')\n\t\t\t\t.catch(() => null);\n\n\t\t\tif (!result) return {};\n\n\t\t\treturn { headers: { Authorization: `Bearer ${result.token}` } };\n\t\t}\n\t\tcase 'mcpOAuth2Api': {\n\t\t\tconst result = await ctx\n\t\t\t\t.getCredentials<{ oauthTokenData: { access_token: string } }>('mcpOAuth2Api')\n\t\t\t\t.catch(() => null);\n\n\t\t\tif (!result) return {};\n\n\t\t\treturn { headers: { Authorization: `Bearer ${result.oauthTokenData.access_token}` } };\n\t\t}\n\t\tcase 'none':\n\t\tdefault: {\n\t\t\treturn {};\n\t\t}\n\t}\n}\n\n/**\n * Tries to refresh the OAuth2 token, storing them in the database if successful\n * @param ctx - The execution context\n * @param authentication - The authentication method\n * @param headers - The headers to refresh\n * @returns The refreshed headers or null if the authentication method is not oAuth2Api or has failed\n */\nexport async function tryRefreshOAuth2Token(\n\tctx: IExecuteFunctions | ISupplyDataFunctions | ILoadOptionsFunctions,\n\tauthentication: McpAuthenticationOption,\n\theaders?: Record<string, string>,\n) {\n\tif (authentication !== 'mcpOAuth2Api') {\n\t\treturn null;\n\t}\n\n\tlet access_token: string | null = null;\n\ttry {\n\t\tconst result = (await ctx.helpers.refreshOAuth2Token.call(\n\t\t\tctx,\n\t\t\t'mcpOAuth2Api',\n\t\t)) as ClientOAuth2TokenData;\n\t\taccess_token = result?.access_token;\n\t} catch (error) {\n\t\treturn null;\n\t}\n\n\tif (!access_token) {\n\t\treturn null;\n\t}\n\n\tif (!headers) {\n\t\treturn {\n\t\t\tAuthorization: `Bearer ${access_token}`,\n\t\t};\n\t}\n\n\treturn {\n\t\t...headers,\n\t\tAuthorization: `Bearer ${access_token}`,\n\t};\n}\n"],"mappings":"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","names":[]}