{"version":3,"sources":["../../../../../nodes/Guardrails/actions/checks/urls.ts"],"sourcesContent":["// Source: https://github.com/openai/openai-guardrails-js/blob/b9b99b4fb454f02a362c2836aec6285176ec40a8/src/checks/urls.ts\n\nimport type { CreateCheckFn, GuardrailResult } from '../types';\n\nexport type UrlsConfig = {\n\tallowedUrls: string[];\n\tallowedSchemes: string[];\n\tblockUserinfo: boolean;\n\tallowSubdomains: boolean;\n};\n\n/**\n * Convert IPv4 address string to 32-bit integer for CIDR calculations.\n */\nfunction ipToInt(ip: string): number {\n\tconst parts = ip.split('.').map(Number);\n\tif (parts.length !== 4 || parts.some((part) => part < 0 || part > 255)) {\n\t\tthrow new Error(`Invalid IP address: ${ip}`);\n\t}\n\treturn (parts[0] << 24) + (parts[1] << 16) + (parts[2] << 8) + parts[3];\n}\n\n/**\n * Detect URLs in text using robust regex patterns.\n */\nfunction detectUrls(text: string): string[] {\n\t// Pattern for cleaning trailing punctuation (] must be escaped)\n\tconst PUNCTUATION_CLEANUP = /[.,;:!?)\\\\]]+$/;\n\n\tconst detectedUrls: string[] = [];\n\n\t// Pattern 1: URLs with schemes (highest priority)\n\tconst schemePatterns = [\n\t\t/https?:\\/\\/[^\\s<>\"{}|\\\\^`\\[\\]]+/gi,\n\t\t/ftp:\\/\\/[^\\s<>\"{}|\\\\^`\\[\\]]+/gi,\n\t\t/data:[^\\s<>\"{}|\\\\^`\\[\\]]+/gi,\n\t\t/javascript:[^\\s<>\"{}|\\\\^`\\[\\]]+/gi,\n\t\t/vbscript:[^\\s<>\"{}|\\\\^`\\[\\]]+/gi,\n\t\t/mailto:[^\\s<>\"{}|\\\\^`\\[\\]]+/gi,\n\t];\n\n\tconst schemeUrls = new Set<string>();\n\tfor (const pattern of schemePatterns) {\n\t\tconst matches = text.match(pattern) || [];\n\t\tfor (let match of matches) {\n\t\t\t// Clean trailing punctuation\n\t\t\tmatch = match.replace(PUNCTUATION_CLEANUP, '');\n\t\t\tif (match) {\n\t\t\t\tdetectedUrls.push(match);\n\t\t\t\t// Track the domain part to avoid duplicates\n\t\t\t\tif (match.includes('://')) {\n\t\t\t\t\tconst domainPart = match.split('://', 2)[1].split('/')[0].split('?')[0].split('#')[0];\n\t\t\t\t\tschemeUrls.add(domainPart.toLowerCase());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Pattern 2: Domain-like patterns without schemes (exclude already found)\n\tconst domainPattern = /\\b(?:www\\.)?[a-zA-Z0-9][a-zA-Z0-9.-]*\\.[a-zA-Z]{2,}(?:\\/[^\\s]*)?/gi;\n\tconst domainMatches = text.match(domainPattern) || [];\n\n\tfor (let match of domainMatches) {\n\t\t// Clean trailing punctuation\n\t\tmatch = match.replace(PUNCTUATION_CLEANUP, '');\n\t\tif (match) {\n\t\t\t// Extract just the domain part for comparison\n\t\t\tconst domainPart = match.split('/')[0].split('?')[0].split('#')[0].toLowerCase();\n\t\t\t// Only add if we haven't already found this domain with a scheme\n\t\t\tif (!schemeUrls.has(domainPart)) {\n\t\t\t\tdetectedUrls.push(match);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Pattern 3: IP addresses (exclude already found)\n\tconst ipPattern = /\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}(?::[0-9]+)?(?:\\/[^\\s]*)?/g;\n\tconst ipMatches = text.match(ipPattern) || [];\n\n\tfor (let match of ipMatches) {\n\t\t// Clean trailing punctuation\n\t\tmatch = match.replace(PUNCTUATION_CLEANUP, '');\n\t\tif (match) {\n\t\t\t// Extract IP part for comparison\n\t\t\tconst ipPart = match.split('/')[0].split('?')[0].split('#')[0].toLowerCase();\n\t\t\tif (!schemeUrls.has(ipPart)) {\n\t\t\t\tdetectedUrls.push(match);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Advanced deduplication: Remove domains that are already part of full URLs\n\tconst finalUrls: string[] = [];\n\tconst schemeUrlDomains = new Set<string>();\n\n\t// First pass: collect all domains from scheme-ful URLs\n\tfor (const url of detectedUrls) {\n\t\tif (url.includes('://')) {\n\t\t\ttry {\n\t\t\t\tconst parsed = new URL(url);\n\t\t\t\tif (parsed.hostname) {\n\t\t\t\t\tschemeUrlDomains.add(parsed.hostname.toLowerCase());\n\t\t\t\t\t// Also add www-stripped version\n\t\t\t\t\tconst bareDomain = parsed.hostname.toLowerCase().replace(/^www\\./, '');\n\t\t\t\t\tschemeUrlDomains.add(bareDomain);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Skip URLs with parsing errors (malformed URLs, encoding issues)\n\t\t\t\t// This is expected for edge cases and doesn't require logging\n\t\t\t}\n\t\t\tfinalUrls.push(url);\n\t\t}\n\t}\n\n\t// Second pass: only add scheme-less URLs if their domain isn't already covered\n\tfor (const url of detectedUrls) {\n\t\tif (!url.includes('://')) {\n\t\t\t// Check if this domain is already covered by a full URL\n\t\t\tconst urlLower = url.toLowerCase().replace(/^www\\./, '');\n\t\t\tif (!schemeUrlDomains.has(urlLower)) {\n\t\t\t\tfinalUrls.push(url);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove empty URLs and return unique list\n\treturn [...new Set(finalUrls.filter((url) => url))];\n}\n\n/**\n * Validate URL against security configuration.\n */\nfunction validateUrlSecurity(\n\turlString: string,\n\tconfig: UrlsConfig,\n): { parsedUrl: URL | null; reason: string } {\n\ttry {\n\t\tlet parsedUrl: URL;\n\t\tlet originalScheme: string;\n\n\t\t// Parse URL - preserve original scheme for validation\n\t\tif (urlString.includes('://')) {\n\t\t\t// Standard URL with double-slash scheme (http://, https://, ftp://, etc.)\n\t\t\tparsedUrl = new URL(urlString);\n\t\t\toriginalScheme = parsedUrl.protocol.replace(':', '');\n\t\t} else if (\n\t\t\turlString.includes(':') &&\n\t\t\turlString.split(':', 1)[0].match(/^(data|javascript|vbscript|mailto)$/)\n\t\t) {\n\t\t\t// Special single-colon schemes\n\t\t\tparsedUrl = new URL(urlString);\n\t\t\toriginalScheme = parsedUrl.protocol.replace(':', '');\n\t\t} else {\n\t\t\t// Add http scheme for parsing, but remember this is a default\n\t\t\tparsedUrl = new URL(`http://${urlString}`);\n\t\t\toriginalScheme = 'http'; // Default scheme for scheme-less URLs\n\t\t}\n\n\t\t// Basic validation: must have scheme and hostname (except for special schemes)\n\t\tif (!parsedUrl.protocol) {\n\t\t\treturn { parsedUrl: null, reason: 'Invalid URL format' };\n\t\t}\n\n\t\t// Special schemes like data: and javascript: don't need hostname\n\t\tconst specialSchemes = new Set(['data:', 'javascript:', 'vbscript:', 'mailto:']);\n\t\tif (!specialSchemes.has(parsedUrl.protocol) && !parsedUrl.hostname) {\n\t\t\treturn { parsedUrl: null, reason: 'Invalid URL format' };\n\t\t}\n\n\t\t// Security validations - use original scheme\n\t\tif (!config.allowedSchemes.includes(originalScheme)) {\n\t\t\treturn { parsedUrl: null, reason: `Blocked scheme: ${originalScheme}` };\n\t\t}\n\n\t\tif (config.blockUserinfo && (parsedUrl.username || parsedUrl.password)) {\n\t\t\treturn { parsedUrl: null, reason: 'Contains userinfo (potential credential injection)' };\n\t\t}\n\n\t\t// Everything else (IPs, localhost, private IPs) goes through allow list logic\n\t\treturn { parsedUrl, reason: '' };\n\t} catch (error) {\n\t\t// Provide specific error information for debugging\n\t\tconst errorMessage = error instanceof Error ? error.message : String(error);\n\t\treturn { parsedUrl: null, reason: `Invalid URL format: ${errorMessage}` };\n\t}\n}\n\n/**\n * Check if URL is allowed based on the allow list configuration.\n */\nfunction isUrlAllowed(parsedUrl: URL, allowList: string[], allowSubdomains: boolean): boolean {\n\tif (allowList.length === 0) {\n\t\treturn false;\n\t}\n\n\tconst urlHost = parsedUrl.hostname?.toLowerCase();\n\tif (!urlHost) {\n\t\treturn false;\n\t}\n\n\tfor (const allowedEntry of allowList) {\n\t\tconst entry = allowedEntry.toLowerCase().trim();\n\n\t\t// Handle full URLs with specific paths\n\t\tif (entry.includes('://')) {\n\t\t\ttry {\n\t\t\t\tconst allowedUrl = new URL(entry);\n\t\t\t\tconst allowedHost = allowedUrl.hostname?.toLowerCase();\n\t\t\t\tconst allowedPath = allowedUrl.pathname;\n\n\t\t\t\tif (urlHost === allowedHost) {\n\t\t\t\t\t// Check if the URL path starts with the allowed path\n\t\t\t\t\tif (!allowedPath || allowedPath === '/' || parsedUrl.pathname.startsWith(allowedPath)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid URL in allow list: \"${entry}\" - ${error instanceof Error ? error.message : error}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Handle IP addresses and CIDR blocks\n\t\ttry {\n\t\t\t// Basic IP pattern check\n\t\t\tif (/^\\d+\\.\\d+\\.\\d+\\.\\d+/.test(entry.split('/')[0])) {\n\t\t\t\tif (entry === urlHost) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// Proper CIDR validation\n\t\t\t\tif (entry.includes('/') && urlHost.match(/^\\d+\\.\\d+\\.\\d+\\.\\d+$/)) {\n\t\t\t\t\tconst [network, prefixStr] = entry.split('/');\n\t\t\t\t\tconst prefix = parseInt(prefixStr);\n\n\t\t\t\t\tif (prefix >= 0 && prefix <= 32) {\n\t\t\t\t\t\t// Convert IPs to 32-bit integers for bitwise comparison\n\t\t\t\t\t\tconst networkInt = ipToInt(network);\n\t\t\t\t\t\tconst hostInt = ipToInt(urlHost);\n\n\t\t\t\t\t\t// Create subnet mask\n\t\t\t\t\t\tconst mask = (0xffffffff << (32 - prefix)) >>> 0;\n\n\t\t\t\t\t\t// Check if host is in the network\n\t\t\t\t\t\tif ((networkInt & mask) === (hostInt & mask)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Expected: entry is not an IP address/CIDR, continue to domain matching\n\t\t\t// Only log if it looks like it was intended to be an IP but failed parsing\n\t\t\tif (/^\\d+\\.\\d+/.test(entry)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Warning: Malformed IP address in allow list: \"${entry}\" - ${error instanceof Error ? error.message : error}`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Handle domain matching\n\t\tconst allowedDomain = entry.replace(/^www\\./, '');\n\t\tconst urlDomain = urlHost.replace(/^www\\./, '');\n\n\t\t// Exact match always allowed\n\t\tif (urlDomain === allowedDomain) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Subdomain matching if enabled\n\t\tif (allowSubdomains && urlDomain.endsWith(`.${allowedDomain}`)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Main URL filtering function.\n */\nexport const urls = (data: string, config: UrlsConfig): GuardrailResult => {\n\t// Detect URLs in the text\n\tconst detectedUrls = detectUrls(data);\n\n\tconst allowed: string[] = [];\n\tconst blocked: string[] = [];\n\tconst blockedReasons: string[] = [];\n\n\tfor (const urlString of detectedUrls) {\n\t\t// Validate URL with security checks\n\t\tconst { parsedUrl, reason } = validateUrlSecurity(urlString, config);\n\n\t\tif (parsedUrl === null) {\n\t\t\tblocked.push(urlString);\n\t\t\tblockedReasons.push(`${urlString}: ${reason}`);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Check against allow list\n\t\t// Special schemes (data:, javascript:, mailto:) don't have meaningful hosts\n\t\t// so they only need scheme validation, not host-based allow list checking\n\t\tconst hostlessSchemes = new Set(['data:', 'javascript:', 'vbscript:', 'mailto:']);\n\t\tif (hostlessSchemes.has(parsedUrl.protocol)) {\n\t\t\t// For hostless schemes, only scheme permission matters (no allow list needed)\n\t\t\t// They were already validated for scheme permission in validateUrlSecurity\n\t\t\tallowed.push(urlString);\n\t\t} else if (isUrlAllowed(parsedUrl, config.allowedUrls, config.allowSubdomains)) {\n\t\t\tallowed.push(urlString);\n\t\t} else {\n\t\t\tblocked.push(urlString);\n\t\t\tblockedReasons.push(`${urlString}: Not in allow list`);\n\t\t}\n\t}\n\n\tconst tripwireTriggered = blocked.length > 0;\n\n\treturn {\n\t\tguardrailName: 'urls',\n\t\ttripwireTriggered,\n\t\tinfo: {\n\t\t\tmaskEntities: {\n\t\t\t\tURL: blocked,\n\t\t\t},\n\t\t\tdetected: detectedUrls,\n\t\t\tallowed,\n\t\t\tblocked,\n\t\t\tblockedReasons,\n\t\t},\n\t};\n};\n\nexport const createUrlsCheckFn: CreateCheckFn<UrlsConfig> = (config) => (input: string) =>\n\turls(input, config);\n"],"mappings":"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","names":[]}