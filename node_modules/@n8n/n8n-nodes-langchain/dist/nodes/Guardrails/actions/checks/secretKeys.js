"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var secretKeys_exports = {};
__export(secretKeys_exports, {
  createSecretKeysCheckFn: () => createSecretKeysCheckFn,
  secretKeysCheck: () => secretKeysCheck
});
module.exports = __toCommonJS(secretKeys_exports);
const COMMON_KEY_PREFIXES = [
  "key-",
  "sk-",
  "sk_",
  "pk_",
  "pk-",
  "ghp_",
  "AKIA",
  "xox",
  "SG.",
  "hf_",
  "api-",
  "apikey-",
  "token-",
  "secret-",
  "SHA:",
  "Bearer "
];
const ALLOWED_EXTENSIONS = [
  ".py",
  ".js",
  ".html",
  ".css",
  ".json",
  ".md",
  ".txt",
  ".csv",
  ".xml",
  ".yaml",
  ".yml",
  ".ini",
  ".conf",
  ".config",
  ".log",
  ".sql",
  ".sh",
  ".bat",
  ".dll",
  ".so",
  ".dylib",
  ".jar",
  ".war",
  ".php",
  ".rb",
  ".go",
  ".rs",
  ".ts",
  ".jsx",
  ".vue",
  ".cpp",
  ".c",
  ".h",
  ".cs",
  ".fs",
  ".vb",
  ".doc",
  ".docx",
  ".xls",
  ".xlsx",
  ".ppt",
  ".pptx",
  ".pdf",
  ".jpg",
  ".jpeg",
  ".png"
];
const CONFIGS = {
  strict: {
    min_length: 10,
    min_entropy: 3,
    // Lowered from 3.5 to be more reasonable
    min_diversity: 2,
    strict_mode: true
  },
  balanced: {
    min_length: 10,
    // Lowered to catch more common keys
    min_entropy: 3.8,
    min_diversity: 3,
    strict_mode: false
  },
  permissive: {
    min_length: 30,
    min_entropy: 4,
    min_diversity: 2,
    // Lowered from 3 to be more reasonable
    strict_mode: false
  }
};
function entropy(s) {
  if (s.length === 0) return 0;
  const counts = {};
  for (const c of s) {
    counts[c] = (counts[c] || 0) + 1;
  }
  let entropy2 = 0;
  for (const count of Object.values(counts)) {
    const probability = count / s.length;
    entropy2 -= probability * Math.log2(probability);
  }
  return entropy2;
}
function charDiversity(s) {
  return [
    s.split("").some((c) => c === c.toLowerCase() && c !== c.toUpperCase()),
    // lowercase
    s.split("").some((c) => c === c.toUpperCase() && c !== c.toLowerCase()),
    // uppercase
    s.split("").some((c) => /\d/.test(c)),
    // digits
    s.split("").some((c) => !/\w/.test(c))
    // special characters
  ].filter(Boolean).length;
}
function containsAllowedPattern(text) {
  const urlPattern = /^https?:\/\/[a-zA-Z0-9.-]+\/?[a-zA-Z0-9.\/_-]*$/i;
  if (urlPattern.test(text)) {
    if (COMMON_KEY_PREFIXES.some((prefix) => text.includes(prefix))) {
      return false;
    }
    return true;
  }
  const extPattern = new RegExp(
    `^[^\\s]*(${ALLOWED_EXTENSIONS.map((ext) => ext.replace(".", "\\.")).join("|")})$`,
    "i"
  );
  return extPattern.test(text);
}
function isSecretCandidate(s, cfg, customRegex) {
  if (customRegex) {
    for (const pattern of customRegex) {
      try {
        const regex = new RegExp(pattern);
        if (regex.test(s)) {
          return true;
        }
      } catch {
        continue;
      }
    }
  }
  if (!cfg.strict_mode && containsAllowedPattern(s)) {
    return false;
  }
  const longEnough = s.length >= cfg.min_length;
  const diverse = charDiversity(s) >= cfg.min_diversity;
  if (COMMON_KEY_PREFIXES.some((prefix) => s.startsWith(prefix))) {
    return true;
  }
  if (!(longEnough && diverse)) {
    return false;
  }
  return entropy(s) >= cfg.min_entropy;
}
function detectSecretKeys(text, cfg, config) {
  const words = text.split(/\s+/).map((w) => w.replace(/[*#]/g, ""));
  const secrets = words.filter((w) => isSecretCandidate(w, cfg, config.customRegex));
  return {
    guardrailName: "secretKeys",
    tripwireTriggered: secrets.length > 0,
    info: {
      maskEntities: { SECRET: secrets },
      detectedSecrets: secrets
    }
  };
}
const secretKeysCheck = (data, config) => {
  const cfg = CONFIGS[config.threshold];
  return detectSecretKeys(data, cfg, config);
};
const createSecretKeysCheckFn = (config) => (input) => secretKeysCheck(input, config);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createSecretKeysCheckFn,
  secretKeysCheck
});
//# sourceMappingURL=secretKeys.js.map