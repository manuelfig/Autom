{"version":3,"sources":["../../../../../nodes/vendors/OpenAi/helpers/polling.ts"],"sourcesContent":["import type { IExecuteFunctions } from 'n8n-workflow';\nimport { NodeApiError } from 'n8n-workflow';\n\nexport async function pollUntilAvailable<TResponse>(\n\tctx: IExecuteFunctions,\n\trequest: () => Promise<TResponse>,\n\tcheck: (response: TResponse) => boolean,\n\ttimeoutSeconds: number,\n\tintervalSeconds = 5,\n): Promise<TResponse> {\n\tconst abortSignal = ctx.getExecutionCancelSignal();\n\tlet response: TResponse | undefined;\n\tconst startTime = Date.now();\n\n\twhile (!response || !check(response)) {\n\t\tconst elapsedTime = Date.now() - startTime;\n\t\tif (elapsedTime >= timeoutSeconds * 1000) {\n\t\t\tthrow new NodeApiError(ctx.getNode(), {\n\t\t\t\tmessage: 'Timeout reached',\n\t\t\t\tcode: 500,\n\t\t\t});\n\t\t}\n\n\t\tif (abortSignal?.aborted) {\n\t\t\tthrow new NodeApiError(ctx.getNode(), {\n\t\t\t\tmessage: 'Execution was cancelled',\n\t\t\t\tcode: 500,\n\t\t\t});\n\t\t}\n\n\t\tresponse = await request();\n\n\t\t// Wait before the next polling attempt\n\t\tawait new Promise((resolve) => setTimeout(resolve, intervalSeconds * 1000));\n\t}\n\n\treturn response;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,0BAA6B;AAE7B,eAAsB,mBACrB,KACA,SACA,OACA,gBACA,kBAAkB,GACG;AACrB,QAAM,cAAc,IAAI,yBAAyB;AACjD,MAAI;AACJ,QAAM,YAAY,KAAK,IAAI;AAE3B,SAAO,CAAC,YAAY,CAAC,MAAM,QAAQ,GAAG;AACrC,UAAM,cAAc,KAAK,IAAI,IAAI;AACjC,QAAI,eAAe,iBAAiB,KAAM;AACzC,YAAM,IAAI,iCAAa,IAAI,QAAQ,GAAG;AAAA,QACrC,SAAS;AAAA,QACT,MAAM;AAAA,MACP,CAAC;AAAA,IACF;AAEA,QAAI,aAAa,SAAS;AACzB,YAAM,IAAI,iCAAa,IAAI,QAAQ,GAAG;AAAA,QACrC,SAAS;AAAA,QACT,MAAM;AAAA,MACP,CAAC;AAAA,IACF;AAEA,eAAW,MAAM,QAAQ;AAGzB,UAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,kBAAkB,GAAI,CAAC;AAAA,EAC3E;AAEA,SAAO;AACR;","names":[]}