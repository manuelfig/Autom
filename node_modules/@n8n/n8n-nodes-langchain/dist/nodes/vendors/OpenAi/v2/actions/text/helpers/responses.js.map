{"version":3,"sources":["../../../../../../../../nodes/vendors/OpenAi/v2/actions/text/helpers/responses.ts"],"sourcesContent":["import type { OpenAIClient } from '@langchain/openai';\nimport get from 'lodash/get';\nimport isObject from 'lodash/isObject';\nimport { isObjectEmpty, jsonParse, type IDataObject, type IExecuteFunctions } from 'n8n-workflow';\nimport type { ResponseInputImage } from 'openai/resources/responses/responses';\n\nimport { getBinaryDataFile } from '../../../../helpers/binary-data';\nimport type {\n\tChatContent,\n\tChatInputItem,\n\tChatResponseRequest,\n} from '../../../../helpers/interfaces';\n\nconst toArray = (str: string) => str.split(',').map((e) => e.trim());\n\nconst removeEmptyProperties = <T>(rest: { [key: string]: any }): T => {\n\treturn Object.keys(rest)\n\t\t.filter(\n\t\t\t(k) =>\n\t\t\t\trest[k] !== '' && rest[k] !== undefined && !(isObject(rest[k]) && isObjectEmpty(rest[k])),\n\t\t)\n\t\t.reduce((a, k) => ({ ...a, [k]: rest[k] }), {}) as unknown as T;\n};\n\nexport async function formatInputMessages(\n\tthis: IExecuteFunctions,\n\ti: number,\n\tmessages: IDataObject[],\n) {\n\treturn await Promise.all(\n\t\tmessages.map<Promise<ChatInputItem>>(async (message) => {\n\t\t\tconst role = message.role as ChatInputItem['role'];\n\t\t\tlet content: ChatContent = [];\n\t\t\tif (message.type === 'text' || !message.type) {\n\t\t\t\tcontent = [{ type: 'input_text', text: message.content as string }];\n\t\t\t} else if (message.type === 'image') {\n\t\t\t\tconst detail = (message.imageDetail as ResponseInputImage['detail']) || ('auto' as const);\n\n\t\t\t\tif (message.imageType === 'base64') {\n\t\t\t\t\tconst { fileContent, contentType } = await getBinaryDataFile(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tmessage.binaryPropertyName as string,\n\t\t\t\t\t);\n\t\t\t\t\tconst buffer = await this.helpers.binaryToBuffer(fileContent);\n\t\t\t\t\tcontent = [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'input_image',\n\t\t\t\t\t\t\tdetail,\n\t\t\t\t\t\t\timage_url: `data:${contentType};base64,${buffer.toString('base64')}`,\n\t\t\t\t\t\t},\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tcontent = [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'input_image',\n\t\t\t\t\t\t\tdetail,\n\t\t\t\t\t\t\t...(message.imageType === 'url' && { image_url: message.imageUrl as string }),\n\t\t\t\t\t\t\t...(message.imageType === 'fileId' && { file_id: message.fileId as string }),\n\t\t\t\t\t\t},\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t} else if (message.type === 'file') {\n\t\t\t\tif (message.fileType === 'base64') {\n\t\t\t\t\tconst { fileContent, contentType } = await getBinaryDataFile(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tmessage.binaryPropertyName as string,\n\t\t\t\t\t);\n\t\t\t\t\tconst buffer = await this.helpers.binaryToBuffer(fileContent);\n\t\t\t\t\tcontent = [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'input_file',\n\t\t\t\t\t\t\tfilename: message.fileName as string,\n\t\t\t\t\t\t\tfile_data: `data:${contentType};base64,${buffer.toString('base64')}`,\n\t\t\t\t\t\t},\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tcontent = [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'input_file',\n\t\t\t\t\t\t\t...(message.fileType === 'url' && { file_url: message.fileUrl as string }),\n\t\t\t\t\t\t\t...(message.fileType === 'fileId' && { file_id: message.fileId as string }),\n\t\t\t\t\t\t},\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { role, content };\n\t\t}),\n\t);\n}\n\ninterface CreateRequestOptions {\n\tmodel: string;\n\tmessages: IDataObject[];\n\toptions: IDataObject;\n\tbuiltInTools?: IDataObject;\n\ttools?: OpenAIClient.Responses.FunctionTool[];\n}\n\nexport async function createRequest(\n\tthis: IExecuteFunctions,\n\ti: number,\n\t{ model, messages, options, builtInTools, tools }: CreateRequestOptions,\n): Promise<ChatResponseRequest> {\n\tconst body: ChatResponseRequest = {\n\t\tmodel,\n\t\tinput: await formatInputMessages.call(this, i, messages),\n\t\tparallel_tool_calls: get(options, 'parallelToolCalls', true) as boolean,\n\t\tstore: get(options, 'store', true) as boolean,\n\t\tinstructions: options.instructions as string,\n\t\tmax_output_tokens: options.maxTokens as number,\n\t\tprevious_response_id: options.previousResponseId as string,\n\t\tprompt_cache_key: options.promptCacheKey as string,\n\t\tsafety_identifier: options.safetyIdentifier as string,\n\t\tservice_tier: options.serviceTier as ChatResponseRequest['service_tier'],\n\t\ttemperature: options.temperature as number,\n\t\ttop_p: options.topP as number,\n\t\ttop_logprobs: options.topLogprobs as number,\n\t\ttools,\n\t\tmax_tool_calls: options.maxToolCalls as number,\n\t\tbackground: get(options, 'backgroundMode.values.enabled', false) as boolean,\n\t};\n\n\tif (options.truncation !== undefined) {\n\t\tbody.truncation = !!options.truncation ? 'auto' : 'disabled';\n\t}\n\n\tif (options.conversationId) {\n\t\tbody.conversation = options.conversationId as string;\n\t}\n\n\tif (Array.isArray(options.include) && options.include?.length) {\n\t\tbody.include = options.include as ChatResponseRequest['include'];\n\t}\n\n\tif (options.metadata) {\n\t\tbody.metadata = jsonParse(options.metadata as string, {\n\t\t\terrorMessage: 'Failed to parse metadata',\n\t\t});\n\t}\n\n\tif (options.promptConfig) {\n\t\tconst prompt = get(options, 'promptConfig.promptOptions') as IDataObject;\n\t\tbody.prompt = removeEmptyProperties({\n\t\t\tid: prompt.promptId,\n\t\t\tversion: prompt.version,\n\t\t\t...(prompt.variables && {\n\t\t\t\tvariables: jsonParse(prompt.variables as string, {\n\t\t\t\t\terrorMessage: 'Failed to parse prompt variables',\n\t\t\t\t}),\n\t\t\t}),\n\t\t});\n\t}\n\n\tif (options.reasoning) {\n\t\tconst reasoning = get(options, 'reasoning.reasoningOptions') as IDataObject;\n\t\tbody.reasoning = removeEmptyProperties({\n\t\t\teffort: reasoning.effort,\n\t\t\tsummary: reasoning.summary && reasoning.summary !== 'none' ? reasoning.summary : undefined,\n\t\t});\n\t}\n\n\tif (options.textFormat) {\n\t\tconst textOptions = get(options, 'textFormat.textOptions') as IDataObject;\n\t\tconst textConfig: OpenAIClient.Responses.ResponseTextConfig = {\n\t\t\tverbosity: textOptions.verbosity as OpenAIClient.Responses.ResponseTextConfig['verbosity'],\n\t\t};\n\t\tif (textOptions.type === 'json_schema') {\n\t\t\ttextConfig.format = {\n\t\t\t\ttype: textOptions.type,\n\t\t\t\tname: textOptions.name as string,\n\t\t\t\tschema: jsonParse(textOptions.schema as string, {\n\t\t\t\t\terrorMessage: 'Failed to parse schema',\n\t\t\t\t}),\n\t\t\t};\n\t\t} else if (textOptions.type === 'json_object') {\n\t\t\ttextConfig.format = {\n\t\t\t\ttype: textOptions.type,\n\t\t\t};\n\t\t\tbody.input = [\n\t\t\t\t{\n\t\t\t\t\trole: 'system',\n\t\t\t\t\tcontent: [\n\t\t\t\t\t\t{ type: 'input_text', text: 'You are a helpful assistant designed to output JSON.' },\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t\t...body.input,\n\t\t\t];\n\t\t} else if (textOptions.type === 'text') {\n\t\t\ttextConfig.format = {\n\t\t\t\ttype: textOptions.type,\n\t\t\t};\n\t\t}\n\n\t\tif (textConfig.format) {\n\t\t\ttextConfig.format = removeEmptyProperties(textConfig.format);\n\t\t}\n\n\t\tbody.text = textConfig;\n\t}\n\n\tif (builtInTools) {\n\t\tconst newTools = body.tools ?? [];\n\n\t\tconst webSearchOptions = get(builtInTools, 'webSearch') as IDataObject | undefined;\n\t\tif (webSearchOptions) {\n\t\t\tlet allowedDomains: string[] | undefined;\n\t\t\tconst allowedDomainsRaw = get(webSearchOptions, 'allowedDomains', '') as string;\n\t\t\tif (allowedDomainsRaw) {\n\t\t\t\tallowedDomains = toArray(allowedDomainsRaw);\n\t\t\t}\n\n\t\t\tlet userLocation: OpenAIClient.Responses.WebSearchTool.UserLocation | undefined;\n\t\t\tif (webSearchOptions.country || webSearchOptions.city || webSearchOptions.region) {\n\t\t\t\tuserLocation = {\n\t\t\t\t\ttype: 'approximate',\n\t\t\t\t\tcountry: webSearchOptions.country as string,\n\t\t\t\t\tcity: webSearchOptions.city as string,\n\t\t\t\t\tregion: webSearchOptions.region as string,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tnewTools.push(\n\t\t\t\tremoveEmptyProperties({\n\t\t\t\t\ttype: 'web_search',\n\t\t\t\t\tsearch_context_size: get(webSearchOptions, 'searchContextSize', 'medium') as\n\t\t\t\t\t\t| 'low'\n\t\t\t\t\t\t| 'medium'\n\t\t\t\t\t\t| 'high',\n\t\t\t\t\tuser_location: userLocation,\n\t\t\t\t\t...(allowedDomains && { filters: { allowed_domains: allowedDomains } }),\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tif (builtInTools.codeInterpreter) {\n\t\t\tnewTools.push({\n\t\t\t\ttype: 'code_interpreter',\n\t\t\t\tcontainer: {\n\t\t\t\t\ttype: 'auto',\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\n\t\tif (builtInTools.fileSearch) {\n\t\t\tconst vectorStoreIds = get(builtInTools.fileSearch, 'vectorStoreIds', '[]') as string;\n\t\t\tconst filters = get(builtInTools.fileSearch, 'filters', '{}') as string;\n\t\t\tnewTools.push(\n\t\t\t\tremoveEmptyProperties({\n\t\t\t\t\ttype: 'file_search',\n\t\t\t\t\tvector_store_ids: jsonParse(vectorStoreIds, {\n\t\t\t\t\t\terrorMessage: 'Failed to parse vector store IDs',\n\t\t\t\t\t}),\n\t\t\t\t\tfilters: filters\n\t\t\t\t\t\t? jsonParse(filters, { errorMessage: 'Failed to parse filters' })\n\t\t\t\t\t\t: undefined,\n\t\t\t\t\tmax_num_results: get(builtInTools.fileSearch, 'maxResults') as number,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tbody.tools = newTools;\n\t}\n\n\treturn await removeEmptyProperties(body);\n}\n"],"mappings":"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","names":["isObject","get"]}