{"version":3,"sources":["../../../../../../../nodes/agents/Agent/agents/ToolsAgent/V3/execute.ts"],"sourcesContent":["import type { StreamEvent } from '@langchain/core/dist/tracers/event_stream';\nimport type { IterableReadableStream } from '@langchain/core/dist/utils/stream';\nimport type { BaseChatModel } from '@langchain/core/language_models/chat_models';\nimport type { AIMessageChunk, BaseMessage, MessageContentText } from '@langchain/core/messages';\nimport { AIMessage, trimMessages } from '@langchain/core/messages';\nimport type { ToolCall } from '@langchain/core/messages/tool';\nimport type { ChatPromptTemplate } from '@langchain/core/prompts';\nimport { RunnableSequence } from '@langchain/core/runnables';\nimport { type AgentRunnableSequence, createToolCallingAgent } from 'langchain/agents';\nimport type { BaseChatMemory } from 'langchain/memory';\nimport type { DynamicStructuredTool, Tool } from 'langchain/tools';\nimport omit from 'lodash/omit';\nimport {\n\tjsonParse,\n\tNodeConnectionTypes,\n\tnodeNameToToolName,\n\tNodeOperationError,\n\tsleep,\n} from 'n8n-workflow';\nimport type {\n\tEngineRequest,\n\tGenericValue,\n\tIDataObject,\n\tIExecuteFunctions,\n\tINodeExecutionData,\n\tISupplyDataFunctions,\n\tEngineResponse,\n} from 'n8n-workflow';\nimport assert from 'node:assert';\n\nimport { getPromptInputByType } from '@utils/helpers';\nimport {\n\tgetOptionalOutputParser,\n\ttype N8nOutputParser,\n} from '@utils/output_parsers/N8nOutputParser';\n\nimport {\n\tfixEmptyContentMessage,\n\tgetAgentStepsParser,\n\tgetChatModel,\n\tgetOptionalMemory,\n\tgetTools,\n\tprepareMessages,\n\tpreparePrompt,\n} from '../common';\nimport { SYSTEM_MESSAGE } from '../prompt';\n\ntype ToolCallRequest = {\n\ttool: string;\n\ttoolInput: Record<string, unknown>;\n\ttoolCallId: string;\n\ttype?: string;\n\tlog?: string;\n\tmessageLog?: unknown[];\n};\n\nasync function createEngineRequests(\n\ttoolCalls: ToolCallRequest[],\n\titemIndex: number,\n\ttools: Array<DynamicStructuredTool | Tool>,\n) {\n\treturn toolCalls.map((toolCall) => {\n\t\t// First try to get from metadata (for toolkit tools)\n\t\tconst foundTool = tools.find((tool) => tool.name === toolCall.tool);\n\n\t\tif (!foundTool) return;\n\n\t\tconst nodeName = foundTool.metadata?.sourceNodeName;\n\n\t\t// For toolkit tools, include the tool name so the node knows which tool to execute\n\t\tconst input = foundTool.metadata?.isFromToolkit\n\t\t\t? { ...toolCall.toolInput, tool: toolCall.tool }\n\t\t\t: toolCall.toolInput;\n\n\t\treturn {\n\t\t\tnodeName,\n\t\t\tinput,\n\t\t\ttype: NodeConnectionTypes.AiTool,\n\t\t\tid: toolCall.toolCallId,\n\t\t\tmetadata: {\n\t\t\t\titemIndex,\n\t\t\t},\n\t\t};\n\t});\n}\n\n/**\n * Uses provided tools and tried to get tools from model metadata\n * Some chat model nodes can define built-in tools in their metadata\n */\nfunction getAllTools(model: BaseChatModel, tools: Array<DynamicStructuredTool | Tool>) {\n\tconst modelTools = (model.metadata?.tools as Tool[]) ?? [];\n\tconst allTools = [...tools, ...modelTools];\n\treturn allTools;\n}\n\n/**\n * Creates an agent executor with the given configuration\n */\nfunction createAgentSequence(\n\tmodel: BaseChatModel,\n\ttools: Array<DynamicStructuredTool | Tool>,\n\tprompt: ChatPromptTemplate,\n\t_options: { maxIterations?: number; returnIntermediateSteps?: boolean },\n\toutputParser?: N8nOutputParser,\n\tmemory?: BaseChatMemory,\n\tfallbackModel?: BaseChatModel | null,\n) {\n\tconst agent = createToolCallingAgent({\n\t\tllm: model,\n\t\ttools: getAllTools(model, tools),\n\t\tprompt,\n\t\tstreamRunnable: false,\n\t});\n\n\tlet fallbackAgent: AgentRunnableSequence | undefined;\n\tif (fallbackModel) {\n\t\tfallbackAgent = createToolCallingAgent({\n\t\t\tllm: fallbackModel,\n\t\t\ttools: getAllTools(fallbackModel, tools),\n\t\t\tprompt,\n\t\t\tstreamRunnable: false,\n\t\t});\n\t}\n\tconst runnableAgent = RunnableSequence.from([\n\t\tfallbackAgent ? agent.withFallbacks([fallbackAgent]) : agent,\n\t\tgetAgentStepsParser(outputParser, memory),\n\t\tfixEmptyContentMessage,\n\t]) as AgentRunnableSequence;\n\n\trunnableAgent.singleAction = true;\n\trunnableAgent.streamRunnable = false;\n\n\treturn runnableAgent;\n}\n\ntype IntermediateStep = {\n\taction: {\n\t\ttool: string;\n\t\ttoolInput: Record<string, unknown>;\n\t\tlog: string;\n\t\tmessageLog: unknown[];\n\t\ttoolCallId: string;\n\t\ttype: string;\n\t};\n\tobservation?: string;\n};\n\ntype AgentResult = {\n\toutput: string;\n\tintermediateSteps?: IntermediateStep[];\n\ttoolCalls?: ToolCallRequest[];\n};\n\nasync function processEventStream(\n\tctx: IExecuteFunctions,\n\teventStream: IterableReadableStream<StreamEvent>,\n\titemIndex: number,\n\treturnIntermediateSteps: boolean = false,\n\tmemory?: BaseChatMemory,\n\tinput?: string,\n): Promise<AgentResult> {\n\tconst agentResult: AgentResult = {\n\t\toutput: '',\n\t};\n\n\tif (returnIntermediateSteps) {\n\t\tagentResult.intermediateSteps = [];\n\t}\n\n\tconst toolCalls: ToolCallRequest[] = [];\n\n\tctx.sendChunk('begin', itemIndex);\n\tfor await (const event of eventStream) {\n\t\t// Stream chat model tokens as they come in\n\t\tswitch (event.event) {\n\t\t\tcase 'on_chat_model_stream':\n\t\t\t\tconst chunk = event.data?.chunk as AIMessageChunk;\n\t\t\t\tif (chunk?.content) {\n\t\t\t\t\tconst chunkContent = chunk.content;\n\t\t\t\t\tlet chunkText = '';\n\t\t\t\t\tif (Array.isArray(chunkContent)) {\n\t\t\t\t\t\tfor (const message of chunkContent) {\n\t\t\t\t\t\t\tif (message?.type === 'text') {\n\t\t\t\t\t\t\t\tchunkText += (message as MessageContentText)?.text;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (typeof chunkContent === 'string') {\n\t\t\t\t\t\tchunkText = chunkContent;\n\t\t\t\t\t}\n\t\t\t\t\tctx.sendChunk('item', itemIndex, chunkText);\n\n\t\t\t\t\tagentResult.output += chunkText;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'on_chat_model_end':\n\t\t\t\t// Capture full LLM response with tool calls for intermediate steps\n\t\t\t\tif (event.data) {\n\t\t\t\t\tconst chatModelData = event.data as {\n\t\t\t\t\t\toutput?: { tool_calls?: ToolCall[]; content?: string };\n\t\t\t\t\t};\n\t\t\t\t\tconst output = chatModelData.output;\n\n\t\t\t\t\t// Check if this LLM response contains tool calls\n\t\t\t\t\tif (output?.tool_calls && output.tool_calls.length > 0) {\n\t\t\t\t\t\t// Collect tool calls for request building\n\t\t\t\t\t\tfor (const toolCall of output.tool_calls) {\n\t\t\t\t\t\t\ttoolCalls.push({\n\t\t\t\t\t\t\t\ttool: toolCall.name,\n\t\t\t\t\t\t\t\ttoolInput: toolCall.args,\n\t\t\t\t\t\t\t\ttoolCallId: toolCall.id || 'unknown',\n\t\t\t\t\t\t\t\ttype: toolCall.type || 'tool_call',\n\t\t\t\t\t\t\t\tlog:\n\t\t\t\t\t\t\t\t\toutput.content ||\n\t\t\t\t\t\t\t\t\t`Calling ${toolCall.name} with input: ${JSON.stringify(toolCall.args)}`,\n\t\t\t\t\t\t\t\tmessageLog: [output],\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Also add to intermediate steps if needed\n\t\t\t\t\t\tif (returnIntermediateSteps) {\n\t\t\t\t\t\t\tfor (const toolCall of output.tool_calls) {\n\t\t\t\t\t\t\t\tagentResult.intermediateSteps!.push({\n\t\t\t\t\t\t\t\t\taction: {\n\t\t\t\t\t\t\t\t\t\ttool: toolCall.name,\n\t\t\t\t\t\t\t\t\t\ttoolInput: toolCall.args,\n\t\t\t\t\t\t\t\t\t\tlog:\n\t\t\t\t\t\t\t\t\t\t\toutput.content ||\n\t\t\t\t\t\t\t\t\t\t\t`Calling ${toolCall.name} with input: ${JSON.stringify(toolCall.args)}`,\n\t\t\t\t\t\t\t\t\t\tmessageLog: [output], // Include the full LLM response\n\t\t\t\t\t\t\t\t\t\ttoolCallId: toolCall.id || 'unknown',\n\t\t\t\t\t\t\t\t\t\ttype: toolCall.type || 'tool_call',\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'on_tool_end':\n\t\t\t\t// Capture tool execution results and match with action\n\t\t\t\tif (returnIntermediateSteps && event.data && agentResult.intermediateSteps!.length > 0) {\n\t\t\t\t\tconst toolData = event.data as { output?: string };\n\t\t\t\t\t// Find the matching intermediate step for this tool call\n\t\t\t\t\tconst matchingStep = agentResult.intermediateSteps!.find(\n\t\t\t\t\t\t(step) => !step.observation && step.action.tool === event.name,\n\t\t\t\t\t);\n\t\t\t\t\tif (matchingStep) {\n\t\t\t\t\t\tmatchingStep.observation = toolData.output || '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tctx.sendChunk('end', itemIndex);\n\n\t// Save conversation to memory if memory is connected\n\tif (memory && input && agentResult.output) {\n\t\tawait memory.saveContext({ input }, { output: agentResult.output });\n\t}\n\n\t// Include collected tool calls in the result\n\tif (toolCalls.length > 0) {\n\t\tagentResult.toolCalls = toolCalls;\n\t}\n\n\treturn agentResult;\n}\n\nexport type RequestResponseMetadata = {\n\titemIndex?: number;\n\tpreviousRequests: ToolCallData[];\n\titerationCount?: number;\n};\n\ntype ToolCallData = {\n\taction: {\n\t\ttool: string;\n\t\ttoolInput: Record<string, unknown>;\n\t\tlog: string | number | true | object;\n\t\ttoolCallId: IDataObject | GenericValue | GenericValue[] | IDataObject[];\n\t\ttype: string | number | true | object;\n\t};\n\tobservation: string;\n};\n\nfunction buildSteps(\n\tresponse: EngineResponse<RequestResponseMetadata> | undefined,\n\titemIndex: number,\n): ToolCallData[] {\n\tconst steps: ToolCallData[] = [];\n\n\tif (response) {\n\t\tconst responses = response?.actionResponses ?? [];\n\n\t\tif (response.metadata?.previousRequests) {\n\t\t\tsteps.push(...response.metadata.previousRequests);\n\t\t}\n\n\t\tfor (const tool of responses) {\n\t\t\tif (tool.action?.metadata?.itemIndex !== itemIndex) continue;\n\n\t\t\tconst toolInput: IDataObject = {\n\t\t\t\t...tool.action.input,\n\t\t\t\tid: tool.action.id,\n\t\t\t};\n\t\t\tif (!toolInput || !tool.data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst step = steps.find((step) => step.action.toolCallId === toolInput.id);\n\t\t\tif (step) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Create a synthetic AI message for the messageLog\n\t\t\t// This represents the AI's decision to call the tool\n\t\t\tconst syntheticAIMessage = new AIMessage({\n\t\t\t\tcontent: `Calling ${tool.action.nodeName} with input: ${JSON.stringify(toolInput)}`,\n\t\t\t\ttool_calls: [\n\t\t\t\t\t{\n\t\t\t\t\t\tid: (toolInput?.id as string) ?? 'reconstructed_call',\n\t\t\t\t\t\tname: nodeNameToToolName(tool.action.nodeName),\n\t\t\t\t\t\targs: toolInput,\n\t\t\t\t\t\ttype: 'tool_call',\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\n\t\t\tconst toolResult = {\n\t\t\t\taction: {\n\t\t\t\t\ttool: nodeNameToToolName(tool.action.nodeName),\n\t\t\t\t\ttoolInput: (toolInput.input as IDataObject) || {},\n\t\t\t\t\tlog: toolInput.log || syntheticAIMessage.content,\n\t\t\t\t\tmessageLog: [syntheticAIMessage],\n\t\t\t\t\ttoolCallId: toolInput?.id,\n\t\t\t\t\ttype: toolInput.type || 'tool_call',\n\t\t\t\t},\n\t\t\t\tobservation: JSON.stringify(tool.data?.data?.ai_tool?.[0]?.map((item) => item?.json) ?? ''),\n\t\t\t};\n\n\t\t\tsteps.push(toolResult);\n\t\t}\n\t}\n\treturn steps;\n}\n\n/* -----------------------------------------------------------\n   Main Executor Function\n----------------------------------------------------------- */\n/**\n * The main executor method for the Tools Agent.\n *\n * This function retrieves necessary components (model, memory, tools), prepares the prompt,\n * creates the agent, and processes each input item. The error handling for each item is also\n * managed here based on the node's continueOnFail setting.\n *\n * @param this Execute context. SupplyDataContext is passed when agent is as a tool\n *\n * @returns The array of execution data for all processed items\n */\nexport async function toolsAgentExecute(\n\tthis: IExecuteFunctions | ISupplyDataFunctions,\n\tresponse?: EngineResponse<RequestResponseMetadata>,\n): Promise<INodeExecutionData[][] | EngineRequest<RequestResponseMetadata>> {\n\tthis.logger.debug('Executing Tools Agent V3');\n\n\tconst returnData: INodeExecutionData[] = [];\n\tlet request: EngineRequest<RequestResponseMetadata> | undefined = undefined;\n\n\tconst items = this.getInputData();\n\tconst batchSize = this.getNodeParameter('options.batching.batchSize', 0, 1) as number;\n\tconst delayBetweenBatches = this.getNodeParameter(\n\t\t'options.batching.delayBetweenBatches',\n\t\t0,\n\t\t0,\n\t) as number;\n\tconst needsFallback = this.getNodeParameter('needsFallback', 0, false) as boolean;\n\tconst memory = await getOptionalMemory(this);\n\tconst model = await getChatModel(this, 0);\n\tassert(model, 'Please connect a model to the Chat Model input');\n\tconst fallbackModel = needsFallback ? await getChatModel(this, 1) : null;\n\n\tif (needsFallback && !fallbackModel) {\n\t\tthrow new NodeOperationError(\n\t\t\tthis.getNode(),\n\t\t\t'Please connect a model to the Fallback Model input or disable the fallback option',\n\t\t);\n\t}\n\n\tfor (let i = 0; i < items.length; i += batchSize) {\n\t\tconst batch = items.slice(i, i + batchSize);\n\t\tconst batchPromises = batch.map(async (_item, batchItemIndex) => {\n\t\t\tconst itemIndex = i + batchItemIndex;\n\n\t\t\tif (response && response?.metadata?.itemIndex === itemIndex) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst steps = buildSteps(response, itemIndex);\n\n\t\t\tconst input = getPromptInputByType({\n\t\t\t\tctx: this,\n\t\t\t\ti: itemIndex,\n\t\t\t\tinputKey: 'text',\n\t\t\t\tpromptTypeKey: 'promptType',\n\t\t\t});\n\t\t\tif (input === undefined) {\n\t\t\t\tthrow new NodeOperationError(this.getNode(), 'The \"text\" parameter is empty.');\n\t\t\t}\n\t\t\tconst outputParser = await getOptionalOutputParser(this, itemIndex);\n\t\t\tconst tools = await getTools(this, outputParser);\n\t\t\tconst options = this.getNodeParameter('options', itemIndex) as {\n\t\t\t\tsystemMessage?: string;\n\t\t\t\tmaxIterations?: number;\n\t\t\t\treturnIntermediateSteps?: boolean;\n\t\t\t\tpassthroughBinaryImages?: boolean;\n\t\t\t\tenableStreaming?: boolean;\n\t\t\t\tmaxTokensFromMemory?: number;\n\t\t\t};\n\n\t\t\tif (options.enableStreaming === undefined) {\n\t\t\t\toptions.enableStreaming = true;\n\t\t\t}\n\n\t\t\t// Prepare the prompt messages and prompt template.\n\t\t\tconst messages = await prepareMessages(this, itemIndex, {\n\t\t\t\tsystemMessage: options.systemMessage,\n\t\t\t\tpassthroughBinaryImages: options.passthroughBinaryImages ?? true,\n\t\t\t\toutputParser,\n\t\t\t});\n\t\t\tconst prompt: ChatPromptTemplate = preparePrompt(messages);\n\n\t\t\t// Create executors for primary and fallback models\n\t\t\tconst executor = createAgentSequence(\n\t\t\t\tmodel,\n\t\t\t\ttools,\n\t\t\t\tprompt,\n\t\t\t\toptions,\n\t\t\t\toutputParser,\n\t\t\t\tmemory,\n\t\t\t\tfallbackModel,\n\t\t\t);\n\t\t\t// Invoke with fallback logic\n\t\t\tconst invokeParams = {\n\t\t\t\tsteps,\n\t\t\t\tinput,\n\t\t\t\tsystem_message: options.systemMessage ?? SYSTEM_MESSAGE,\n\t\t\t\tformatting_instructions:\n\t\t\t\t\t'IMPORTANT: For your response to user, you MUST use the `format_final_json_response` tool with your complete answer formatted according to the required schema. Do not attempt to format the JSON manually - always use this tool. Your response will be rejected if it is not properly formatted through this tool. Only use this tool once you are ready to provide your final answer.',\n\t\t\t};\n\t\t\tconst executeOptions = { signal: this.getExecutionCancelSignal() };\n\n\t\t\t// Check if streaming is actually available\n\t\t\tconst isStreamingAvailable = 'isStreaming' in this ? this.isStreaming?.() : undefined;\n\n\t\t\tif (\n\t\t\t\t'isStreaming' in this &&\n\t\t\t\toptions.enableStreaming &&\n\t\t\t\tisStreamingAvailable &&\n\t\t\t\tthis.getNode().typeVersion >= 2.1\n\t\t\t) {\n\t\t\t\tlet chatHistory: BaseMessage[] | undefined = undefined;\n\t\t\t\tif (memory) {\n\t\t\t\t\t// Load memory variables to respect context window length\n\t\t\t\t\tchatHistory = await loadChatHistory(memory, model, options.maxTokensFromMemory);\n\t\t\t\t}\n\t\t\t\tconst eventStream = executor.streamEvents(\n\t\t\t\t\t{\n\t\t\t\t\t\t...invokeParams,\n\t\t\t\t\t\tchat_history: chatHistory,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tversion: 'v2',\n\t\t\t\t\t\t...executeOptions,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tconst result = await processEventStream(\n\t\t\t\t\tthis,\n\t\t\t\t\teventStream,\n\t\t\t\t\titemIndex,\n\t\t\t\t\toptions.returnIntermediateSteps,\n\t\t\t\t\tmemory,\n\t\t\t\t\tinput,\n\t\t\t\t);\n\n\t\t\t\t// If result contains tool calls, build the request object like the normal flow\n\t\t\t\tif (result.toolCalls && result.toolCalls.length > 0) {\n\t\t\t\t\tconst currentIteration = (response?.metadata?.iterationCount ?? 0) + 1;\n\n\t\t\t\t\t// Check if we've exceeded maxIterations\n\t\t\t\t\tif (options.maxIterations && currentIteration > options.maxIterations) {\n\t\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Maximum iterations reached');\n\t\t\t\t\t}\n\n\t\t\t\t\tconst actions = await createEngineRequests(result.toolCalls, itemIndex, tools);\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tactions,\n\t\t\t\t\t\tmetadata: {\n\t\t\t\t\t\t\tpreviousRequests: buildSteps(response, itemIndex),\n\t\t\t\t\t\t\titerationCount: currentIteration,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\t// Handle regular execution\n\t\t\t\tlet chatHistory: BaseMessage[] | undefined = undefined;\n\t\t\t\tif (memory) {\n\t\t\t\t\t// Load memory variables to respect context window length\n\t\t\t\t\tchatHistory = await loadChatHistory(memory, model, options.maxTokensFromMemory);\n\t\t\t\t}\n\t\t\t\tconst modelResponse = await executor.invoke({\n\t\t\t\t\t...invokeParams,\n\t\t\t\t\tchat_history: chatHistory,\n\t\t\t\t});\n\n\t\t\t\tif ('returnValues' in modelResponse) {\n\t\t\t\t\t// Save conversation to memory including any tool call context\n\t\t\t\t\tif (memory && input && modelResponse.returnValues.output) {\n\t\t\t\t\t\t// If there were tool calls in this conversation, include them in the context\n\t\t\t\t\t\tlet fullOutput = modelResponse.returnValues.output as string;\n\n\t\t\t\t\t\tif (steps.length > 0) {\n\t\t\t\t\t\t\t// Include tool call information in the conversation context\n\t\t\t\t\t\t\tconst toolContext = steps\n\t\t\t\t\t\t\t\t.map(\n\t\t\t\t\t\t\t\t\t(step) =>\n\t\t\t\t\t\t\t\t\t\t`Tool: ${step.action.tool}, Input: ${JSON.stringify(step.action.toolInput)}, Result: ${step.observation}`,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t.join('; ');\n\t\t\t\t\t\t\tfullOutput = `[Used tools: ${toolContext}] ${fullOutput}`;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tawait memory.saveContext({ input }, { output: fullOutput });\n\t\t\t\t\t}\n\t\t\t\t\t// Include intermediate steps if requested\n\t\t\t\t\tconst result = { ...modelResponse.returnValues };\n\t\t\t\t\tif (options.returnIntermediateSteps && steps.length > 0) {\n\t\t\t\t\t\tresult.intermediateSteps = steps;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tconst currentIteration = (response?.metadata?.iterationCount ?? 0) + 1;\n\n\t\t\t\t// Check if we've exceeded maxIterations\n\t\t\t\tif (options.maxIterations && currentIteration > options.maxIterations) {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), 'Maximum iterations reached');\n\t\t\t\t}\n\n\t\t\t\tconst actions = await createEngineRequests(modelResponse, itemIndex, tools);\n\n\t\t\t\treturn {\n\t\t\t\t\tactions,\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tpreviousRequests: buildSteps(response, itemIndex),\n\t\t\t\t\t\titerationCount: currentIteration,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tconst batchResults = await Promise.allSettled(batchPromises);\n\t\t// This is only used to check if the output parser is connected\n\t\t// so we can parse the output if needed. Actual output parsing is done in the loop above\n\t\tconst outputParser = await getOptionalOutputParser(this, 0);\n\t\tbatchResults.forEach((result, index) => {\n\t\t\tconst itemIndex = i + index;\n\t\t\tif (result.status === 'rejected') {\n\t\t\t\tconst error = result.reason as Error;\n\t\t\t\tif (this.continueOnFail()) {\n\t\t\t\t\treturnData.push({\n\t\t\t\t\t\tjson: { error: error.message },\n\t\t\t\t\t\tpairedItem: { item: itemIndex },\n\t\t\t\t\t} as INodeExecutionData);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NodeOperationError(this.getNode(), error);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst response = result.value;\n\n\t\t\tif ('actions' in response) {\n\t\t\t\tif (!request) {\n\t\t\t\t\trequest = {\n\t\t\t\t\t\tactions: response.actions,\n\t\t\t\t\t\tmetadata: response.metadata,\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\trequest.actions.push(...response.actions);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If memory and outputParser are connected, parse the output.\n\t\t\tif (memory && outputParser) {\n\t\t\t\tconst parsedOutput = jsonParse<{ output: Record<string, unknown> }>(\n\t\t\t\t\tresponse.output as string,\n\t\t\t\t);\n\t\t\t\tresponse.output = parsedOutput?.output ?? parsedOutput;\n\t\t\t}\n\n\t\t\t// Omit internal keys before returning the result.\n\t\t\tconst itemResult: INodeExecutionData = {\n\t\t\t\tjson: omit(\n\t\t\t\t\tresponse,\n\t\t\t\t\t'system_message',\n\t\t\t\t\t'formatting_instructions',\n\t\t\t\t\t'input',\n\t\t\t\t\t'chat_history',\n\t\t\t\t\t'agent_scratchpad',\n\t\t\t\t),\n\t\t\t\tpairedItem: { item: itemIndex },\n\t\t\t};\n\n\t\t\treturnData.push(itemResult);\n\t\t});\n\n\t\tif (i + batchSize < items.length && delayBetweenBatches > 0) {\n\t\t\tawait sleep(delayBetweenBatches);\n\t\t}\n\t}\n\t// Check if we have any Request objects (tool calls)\n\tif (request) {\n\t\treturn request;\n\t}\n\n\t// Otherwise return execution data\n\treturn [returnData];\n}\nasync function loadChatHistory(\n\tmemory: BaseChatMemory,\n\tmodel: BaseChatModel,\n\tmaxTokensFromMemory?: number,\n): Promise<BaseMessage[]> {\n\tconst memoryVariables = await memory.loadMemoryVariables({});\n\tlet chatHistory = memoryVariables['chat_history'] as BaseMessage[];\n\n\tif (maxTokensFromMemory) {\n\t\tchatHistory = await trimMessages(chatHistory, {\n\t\t\tstrategy: 'last',\n\t\t\tmaxTokens: maxTokensFromMemory,\n\t\t\ttokenCounter: model,\n\t\t\tincludeSystem: true,\n\t\t\tstartOn: 'human',\n\t\t\tallowPartial: true,\n\t\t});\n\t}\n\n\treturn chatHistory;\n}\n"],"mappings":"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","names":["step","assert","outputParser","response","omit"]}