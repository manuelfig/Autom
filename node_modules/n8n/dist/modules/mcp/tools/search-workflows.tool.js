"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSearchWorkflowsTool = void 0;
exports.searchWorkflows = searchWorkflows;
const zod_1 = __importDefault(require("zod"));
const mcp_constants_1 = require("../mcp.constants");
const schemas_1 = require("./schemas");
const MAX_RESULTS = 200;
const inputSchema = {
    limit: zod_1.default
        .number()
        .int()
        .positive()
        .max(MAX_RESULTS)
        .optional()
        .describe(`Limit the number of results (max ${MAX_RESULTS})`),
    query: zod_1.default.string().optional().describe('Filter by name or description'),
    projectId: zod_1.default.string().optional(),
};
const outputSchema = {
    data: zod_1.default
        .array(zod_1.default.object({
        id: zod_1.default.string(),
        name: zod_1.default.string().nullable(),
        description: zod_1.default.string().nullable(),
        active: zod_1.default.boolean().nullable(),
        createdAt: zod_1.default.string().nullable(),
        updatedAt: zod_1.default.string().nullable(),
        triggerCount: zod_1.default.number().nullable(),
        nodes: zod_1.default.array(schemas_1.nodeSchema),
    }))
        .describe('List of workflows matching the query'),
    count: zod_1.default.number().int().min(0).describe('Total number of workflows that match the filters'),
};
const createSearchWorkflowsTool = (user, workflowService, telemetry) => {
    return {
        name: 'search_workflows',
        config: {
            description: 'Search for workflows with optional filters. Returns a preview of each workflow.',
            inputSchema,
            outputSchema,
        },
        handler: async ({ limit = MAX_RESULTS, query, projectId }) => {
            const parameters = { limit, query, projectId };
            const telemetryPayload = {
                user_id: user.id,
                tool_name: 'search_workflows',
                parameters,
            };
            try {
                const payload = await searchWorkflows(user, workflowService, {
                    limit,
                    query,
                    projectId,
                });
                telemetryPayload.results = {
                    success: true,
                    data: {
                        count: payload.count,
                    },
                };
                telemetry.track(mcp_constants_1.USER_CALLED_MCP_TOOL_EVENT, telemetryPayload);
                return {
                    structuredContent: payload,
                    content: [
                        {
                            type: 'text',
                            text: JSON.stringify(payload),
                        },
                    ],
                };
            }
            catch (error) {
                telemetryPayload.results = {
                    success: false,
                    error: error instanceof Error ? error.message : String(error),
                };
                telemetry.track(mcp_constants_1.USER_CALLED_MCP_TOOL_EVENT, telemetryPayload);
                throw error;
            }
        },
    };
};
exports.createSearchWorkflowsTool = createSearchWorkflowsTool;
async function searchWorkflows(user, workflowService, { limit = MAX_RESULTS, query, projectId }) {
    const safeLimit = Math.min(Math.max(1, limit), MAX_RESULTS);
    const options = {
        take: safeLimit,
        filter: {
            isArchived: false,
            availableInMCP: true,
            active: true,
            ...(query ? { query } : {}),
            ...(projectId ? { projectId } : {}),
        },
        select: {
            id: true,
            name: true,
            description: true,
            active: true,
            createdAt: true,
            updatedAt: true,
            triggerCount: true,
            nodes: true,
        },
    };
    const { workflows, count } = await workflowService.getMany(user, options, false, false, false);
    const formattedWorkflows = workflows.map(({ id, name, description, active, createdAt, updatedAt, triggerCount, nodes }) => ({
        id,
        name,
        description,
        active,
        createdAt: createdAt.toISOString(),
        updatedAt: updatedAt.toISOString(),
        triggerCount,
        nodes: (nodes ?? []).map((node) => ({ name: node.name, type: node.type })),
    }));
    return { data: formattedWorkflows, count };
}
//# sourceMappingURL=search-workflows.tool.js.map